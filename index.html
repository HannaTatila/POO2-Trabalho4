<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>Poo2-trabalho4 by HannaTatila</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">Poo2-trabalho4</h1>
      <h2 class="project-tagline">Trabalho 4 da disciplina de POO2 - Criação do game Mar&amp;moto.</h2>
      <a href="https://github.com/HannaTatila/POO2-Trabalho4" class="btn">View on GitHub</a>
      <a href="https://github.com/HannaTatila/POO2-Trabalho4/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/HannaTatila/POO2-Trabalho4/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <h2>
<a id="trabalho-de-poo2" class="anchor" href="#trabalho-de-poo2" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>
<b>Trabalho de POO2</b> </h2>

<p><br>
<b>Projeto:</b> Mar&amp;moto<br>
<b>Responsável:</b> Hanna Tátila de Sousa e Neimar Paulo Alves<br>
<br>
<br></p>

<h4>
<a id="1-sumário" class="anchor" href="#1-sum%C3%A1rio" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>
<b>1. Sumário</b> </h4>

<ul>
<li>Descrição do propósito do sistema</li>
<li>Minimundo</li>
<li>Diagrama de Classe</li>
<li>Padrões de Projeto</li>
<li>MVC</li>
<li>Teste de qualidade de código</li>
<li>Guia do jogador
<br>
<br>
<br>
<br>
<h4>
<a id="2-descrição-do-propósito-do-sistema" class="anchor" href="#2-descri%C3%A7%C3%A3o-do-prop%C3%B3sito-do-sistema" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>
<b>2. Descrição do Propósito do Sistema</b> </h4>
 O sistema se trata de um jogo de distância que contém vários desafios e convida o usuário a percorrer longas distâncias, marcando muitos pontos. O jogo é sem fim, não possui níveis. A única finalidade é percorrer o maior número de distância possível, não ser atingido pelos obstáculos e coletar os bônus disponíveis na fase.<br>
<br>
<h4>
<a id="3-descrição-do-minimundo" class="anchor" href="#3-descri%C3%A7%C3%A3o-do-minimundo" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>
<b>3. Descrição do Minimundo</b> </h4>
 A empresa desenvolvedora de jogos HTSGames precisa criar um novo jogo que prenda a atenção e desafie seus jogadores. Pensando nisso, a HTSGames planeja criar um jogo de distância.<br>
<br>
 Esse jogo possui como personagem principal um adorável peixinho. O peixinho precisa desviar de vários obstáculos marinhos que aparecem em seu caminho. A cada obstáculo ultrapassado, a pontuação é incrementada. Sendo que o personagem possui três vidas iniciais. A cada vez que é atingido por um obstáculo, o personagem perde uma vida. Se todas as vidas forem perdidas, o jogo é finalizado. Ao decorrer do jogo, aparecerão bônus em forma de moeda que devem ser coletados. Assim que atingir uma determinada quantidade de moedas coletadas, o peixinho evolui e fica mais "forte", se transformando em um peixe ousado montado em sua moto radical. Por isso, se atingido por algum obstáculo enquanto estiver no estado de evolução, ele não perde uma vida, apenas perde os poderes e benefícios vindos da evolução e volta a ser um peixinho adorável. Quando o peixinho evolui, seus poderes acabam invocando novos inimigos vindos do mundo dos mortos. O peixe então, agora precisa desviar de mais esses obstáculos, porém esses novos inimigos só aparecem para atrapalhar, eles não incrementam a pontuação do jogador quando ultrapassados.<br>
<br>
 Além disso, ao iniciar o jogo, o jogador precisa informar um nome que depois será associado à pontuação máxima atingida pelo jogador. O cadastro de nome possui algumas restrições, como: quantidade máxima de 10 caracteres, sendo que não pode conter caracteres especiais. Toda vez ao entrar no jogo, o jogador deverá inserir seu nome. Se o nome apresentado já estiver cadastrado, então sua pontuação máxima será atualizada caso ultrapasse seu recorde atual.<br>
<br>
 O jogador terá a possibilidade de consultar o ranking do jogo, que exibe, ordenadamente, a pontuação de cada jogador.<br>
<br>
<br>
<h4>
<a id="4-diagrama-de-classe" class="anchor" href="#4-diagrama-de-classe" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>
<b>4. Diagrama de Classe</b> </h4>
<br>
<img src="https://github.com/HannaTatila/POO2-Trab1/blob/gh-pages/DiagramaClasse_Mar&amp;moto.png?raw=true" alt="">
<br>
<br>
<h4>
<a id="5padrões-de-projeto" class="anchor" href="#5padr%C3%B5es-de-projeto" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>
<b>5.Padrões de Projeto</b> </h4>
<br>
<h4>
<a id="51-padrão-método-fábrica" class="anchor" href="#51-padr%C3%A3o-m%C3%A9todo-f%C3%A1brica" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>
<b>5.1 Padrão Método Fábrica</b> </h4>
<br>
<img src="https://github.com/HannaTatila/POO2-Trab03/blob/master/DiagramaFabrica.png?raw=true" alt="">
<br>
<br>
 O padrão Método Fábrica possui a intenção de definir uma interface para criar um objeto, mas deixar as subclasses decidirem que classe instanciar. O Método Fábrica permite adiar a instanciação para subclasses.
No jogo foi criada uma FabricaSprites para abstrair a criação dos obstáculos, do personagem, das moedas e dos peixes esqueletos.
<br>
<br>
<br>
<h4>
<a id="52-padrão-protótipo" class="anchor" href="#52-padr%C3%A3o-prot%C3%B3tipo" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>
<b>5.2 Padrão Protótipo</b> </h4>
<br>
<img src="https://github.com/HannaTatila/POO2-Trab03/blob/master/DiagramaPrototipo.png?raw=true" alt="">
<br>
<br>
 A intenção do padrão Protótipo é especificar tipos de objetos a serem criados usando uma instância protótipo e criar novos objetos pela cópia desse protótipo.
Precisamos criar novos objetos a partir de uma instância protótipo, que vai realizar uma cópia de si mesmo e retornar para o novo objeto.<br>
Como o jogo cria vários obstáculos, moedas e peixes esqueletos durante uma partida, seria bem mais custoso instanciar toda vez um novo objeto. Aplicando esse padrão, a partir de uma instância de um PeixeEspadaProtótipo, por exemplo, é possível criar vários obstáculos a partir da cópia deste PeixeEspadaProtótipo.
<br>
<br>
<br>
<h4>
<a id="53-padrão-flyweight" class="anchor" href="#53-padr%C3%A3o-flyweight" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>
<b>5.3 Padrão Flyweight</b> </h4>
<br>
<img src="https://github.com/HannaTatila/POO2-Trab03/blob/master/DiagramaFlyweight.png?raw=true" alt="">
<br>
<br>
 A intenção do padrão Flyweight é usar compartilhamento para suportar eficientemente grandes quantidades de objetos de granularidade fina. No jogo em questão, o padrão foi aplicado para o compartilhamento de imagens entre as entidades. A FlyweightFabrica é instanciada, por enquanto, apenas uma vez e nela todas as imagens dos obstáculos, do personagem, da moeda e do peixe esqueleto são carregadas de seus respectivos diretórios. Quando um método requisitar essas imagens (o que acontece várias vezes durante o jogo, já que vários obstáculos são impressos durante uma partida, assim como as moedas e os peixes esqueletos), elas já estarão carregadas e só terão que ser impressas na tela.
<br>
<br>
<br>
<h4>
<a id="54-padrão-singleton" class="anchor" href="#54-padr%C3%A3o-singleton" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>
<b>5.4 Padrão Singleton</b> </h4>
<br>
 A solução implementada pelo padrão Flyweight é bem intuitiva. No entanto, na classe FlyweightFabrica fica centralizado o acesso a todos os objetos compartilhados. O que aconteceria se houvessem duas ou mais instâncias desta classe? Seriam criados vários objetos, sem nenhuma necessidade. Se eu criasse, por exemplo, uma outra AplJogo para utilizar outro módulo de jogo que também fizesse uso do FlyweightFabrica, esses novos objetos seriam criados desnecessariamente.
Para evitar este problema foi implementado o padrão Singleton. Aplicando este padrão na classe fábrica, garantimos que apenas uma instância dela será utilizada em todo o projeto.
<br>
<br>
<br>
<h4>
<a id="55-padrão-state" class="anchor" href="#55-padr%C3%A3o-state" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>
<b>5.5 Padrão State</b> </h4>
<br>
<img src="https://github.com/HannaTatila/POO2-Trabalho4/blob/master/DiagramaState.png?raw=true" alt="">
<br>
<br>
 A intenção do padrão State é permitir a um objeto alterar seu comportamento quando seu estado interno muda. O objeto parecerá ter mudado de classe.<br>
O padrão foi utilizado na implementação do Menu do jogo. Foi criada uma classe EstadoMenu que contém a interface básica de todos os estados do menu(Iniciar, Cadastrar, Ranking e Sair). No caso, as operações básicas que vão fazer parte da interface são: próximo valor, valor anterior e selecionar valor. Segue abaixo a implementação da classe EstadoMenu, demonstrando como representar uma interface em Python:
<br>
<br>
<img src="https://github.com/HannaTatila/POO2-Trabalho4/blob/master/InterfacePython.png?raw=true" alt="">
<br>
<br>
Todos os estados do menu implementaram as operações de troca de estado. Desse modo, cada operação retorna um objeto do tipo EstadoMenu, pois como cada operação representa uma troca de estados, será retornado o novo estado que o menu deve assumir. Dessa forma, a aplicação desse padrão ajuda a abstrair a implementação de cada opção do menu, além de deixar o código mais limpo, evitando o uso de diversos if's para identificar em qual opção do menu o usuário está e deixando o código mais organizado. Da forma que estava implementado antes da aplicação do padrão o código estava extremamente feio, com uma quantidade excessiva de if's e com tudo acontecendo dentro de um mesmo método.
<br>
<br>
<br>
<h4>
<a id="56-padrão-memento" class="anchor" href="#56-padr%C3%A3o-memento" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>
<b>5.6 Padrão Memento</b> </h4>
<br>
<img src="https://github.com/HannaTatila/POO2-Trabalho4/blob/master/DiagramaMemento.png?raw=true" alt="">
<br>
<br>
 O objetivo do padrão Memento é, sem violar o encapsulamento, capturar e externalizar um estado interno de um objeto, de maneira que o objeto possa ser restaurado para esse estado mais tarde. No jogo, quando o jogador coleta uma determinada quantidade de moedas, o jogo em si passa por uma evolução, o fundo, a música e o personagem são alterados.<br> 
O estado interno do objeto é o personagem na forma de peixinho. Assim, o padrão Memento permite capturar o estado do personagem para que depois ele possa ser reutilizado. Então, quando o estado do personagem muda para o motoqueiro, o estado do peixinho fica guardado. Então quando o peixe motoqueiro é atingido por algum obstáculo, o estado do personagem é restaurado.
<br>
<br>
<br>
<h4>
<a id="57-padrão-observer" class="anchor" href="#57-padr%C3%A3o-observer" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>
<b>5.7 Padrão Observer</b> </h4>
<br>
<img src="https://github.com/HannaTatila/POO2-Trabalho4/blob/master/DiagramaObserver.png?raw=true" alt="">
<br>
<br>
O objetivo do padrão Observer é definir uma dependência um para muitos entre objetos, de maneira que quando um objeto muda de estado todos os seus dependentes são notificados e atualizados automaticamente.<br>
Esse padrão foi utilizado para controlar a detecção dos eventos de entrada do usuário através do teclado. Assim, quando uma tecla é digitada, os Controladores do Menu e Jogo são notificados e fazem mudanças relativas aos eventos detectados.
Foi criada uma classe EventosTeclado que mantém o conjunto de dados e uma lista de dependentes deste conjunto de dados, assim a cada vez que o usuário digita uma tecla, todos os dependentes são notificados. 
<br>
<br>
<br>
<h4>
<a id="58-padrão-dao" class="anchor" href="#58-padr%C3%A3o-dao" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>
<b>5.8 Padrão DAO</b> </h4>
<br>
 O padrão de projeto DAO nos permite separar a lógica de negócios da lógica de persistência de dados. Então foi criada uma classe DAOJogador que ficou responsável por trocar informações com o SGBD e fornecer operações de consulta e inserção de dados referentes ao cadastro e validação de dados do jogador.
<br>
<br>
<br>
<h4>
<a id="6-mvc" class="anchor" href="#6-mvc" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>
<b>6. MVC</b> </h4>
<br>
<img src="https://github.com/HannaTatila/POO2-Trab03/blob/master/DiagramaCamadas.png?raw=true" alt="">
<br>
<br>
Foram criadas 4 camadas principais:
<ul>
<li>
<b>CIU:</b> representa a camada de visão. Possui duas outras camadas chamadas CIH, que possui classes referentes às telas (impressão das imagens, textos); e CCI, que possui os controladores. </li>
<li>
<b>CLN:</b> representa a camada de lógica de negócio. Possui duas outras camadas chamadas CGT, que possui as APL's do jogo; e CDP, que possui as classes que representam as entidades principais do sistema.</li>
<li>
<b>CGD:</b> representa a camada de persistência. Possui classes responsáveis por executar ações no banco de dados.</li>
<li>
<b>PRINCIPAL:</b> possui apenas o módulo main do sistema.</li>
</ul>
Além disso existem os diretórios de Recursos, que possuem as imagens e os áudios; e o diretório de testes.
<br>
<br>
Segue abaixo uma imagem retirada do PYCharm mostrando como o jogo foi subdivido em relação à camadas, assim como as classes existentes em cada camada:
<br>
<br>
<img src="https://github.com/HannaTatila/POO2-Trabalho4/blob/master/diretorios.png?raw=true" alt="">
<br>
<br>
<h4>
<a id="7-teste-de-qualidade-de-cÓdigo" class="anchor" href="#7-teste-de-qualidade-de-c%C3%93digo" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>
<b>7. TESTE DE QUALIDADE DE CÓDIGO</b> </h4>
<br>
O teste de qualidade do código foi obtida por meio do software SonarQube. A figura 1 mostra os resultados da primeira análise feita no código. Essa versão possui apenas o Método Fábrica implementado.
<br>
<br>
<img src="https://github.com/HannaTatila/POO2-Trab1/blob/gh-pages/sonar.png?raw=true" alt="">
<br>
<br>
Uma nova análise foi feita em uma versão com implementação da parte de Persistência. A complexidade gral do código aumentou significativamente, talvez por causa das chamadas e retornos exigidas pela implementação da persistência.
<br>
<br>
<img src="https://github.com/HannaTatila/POO2-Trab03/blob/master/sonarPersistenciaFabrica.png?raw=true" alt="">
<br>
<br>
A versão seguinte teve os padrões Protótipo, Flyweight e Singleton implementados. A complexidade geral aumentou, porém a complexidade das funções diminuiu um pouco.
<br>
<br>
<img src="https://github.com/HannaTatila/POO2-Trab03/blob/master/sonarU.png?raw=true" alt="">
<br>
<br>
A versão final do trabalho teve os padrões State, Memento e Observer implementados, além de novas funcionalidades adicionadas ao jogo. Como previsto, a complexidade geral aumentou um pouco, porém todos os outros valores tiveram uma melhora em seus números.
<br>
<br>
<img src="https://github.com/HannaTatila/POO2-Trabalho4/blob/master/sonarTrabalho4.png?raw=true" alt="">
<br>
<br>
Fazendo uma análise geral dos números gerados, foi possível perceber uma boa melhora(segundo as análises do Sonar) com a aplicação dos padrões. Além disso, ao longo do projeto foi possível perceber que a aplicação de parte dos padrões melhorou o desempenho do código. E outra parte tornou o código mais limpo e organizado.
<br>
<br>
<h4>
<a id="7-guia-do-jogador" class="anchor" href="#7-guia-do-jogador" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>
<b>7. Guia do jogador</b> </h4>
<br>
<em>(* Para implementação do jogo foi utilizado o Python 3.4, pygame 1.9.2 e a IDE PyCharm 4.5.4 *)</em>
<br>
<em>(* Para executar a aplicação, abra a IDE PyCharm e nela abra o projeto (File -&gt; Open... -&gt; Procure o projeto e selecione-o). Depois basta rodar a aplicação (no pacote principal clique com o botão direito do mouse sobre a classe App.py e selecione: Run 'App'). *)</em>
<ul>
<li>O jogo é todo controlado por comandos do teclado; </li>
<li>Ao iniciar, o jogo apresenta uma tela de menu com as funcionalidades “INICIAR”, "CADASTRAR", "RANKING" e “SAIR”;</li>
<li>Navegue pelos itens do menu utilizando as setas do teclado para cima e para baixo. Para a cessar as funcionalidades, utilize a tecla Enter;</li>
<li>Para iniciar o jogo é preciso ter um login devidamente cadastrado. Para isso acesse a opção CADASTRAR. Digite seu login e tecle Enter. Digite sua senha e tecle Enter;</li>
<li>Para jogar, acesse a opção INICIAR. Digite seu login e senha cadastrado e tecle Enter;</li>
<li>Para movimentar o peixinho, utilize a seta para cima (você deve apertar e segurar a tecla para o peixinho se movimentar mais rápido);</li>
<li>Se o peixinho encostar em algum inimigo que surgir em seu caminho, terá uma vida descontada (a vida é representada pelas gotinhas no canto superior esquerdo da tela). Caso perca três vidas o jogo será finalizado;</li>
<li>Centralizado na parte superior da tela, é possível observar a 'Pontuação' da fase, que é incrementado toda vez que o peixinho consegue ultrapassar um obstáculo marinho.</li>
<li> No canto superior direito, temos o somatório das moedas coletadas. Quando atingir determinada quantidade de moedas, o peixinho evolui e torna o jogo um pouco mais interessante ;) </li>
<li>Observe que quando o bônus é atingido o ambiente fica especialmente diferente. Novos inimigos surgem e o peixinho não pode deixar ser atingido, caso isso aconteça, o peixinho vai perder sua evolução e o jogo voltará ao estado anterior. Continue coletando moedas para novamente atingir o bônus, que a cada vez precisará de mais moedas para ser atingido.</li>
<li>Para abortar o jogo a qualquer momento, utilize a tecla de espaço.</li>
<li>Para visualizar o ranking do jogo com os recordes dos melhores jogadores, navegue até a opção RANKING do menu e tecle Enter. Para voltar ao menu inicial, tecle Enter novamente.</li>
</ul>
<br>
<br>
</li>
</ul>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/HannaTatila/POO2-Trabalho4">Poo2-trabalho4</a> is maintained by <a href="https://github.com/HannaTatila">HannaTatila</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>
